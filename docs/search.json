[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to Data Dispatches, the online portal for JHU Data Services data tutorials. Here you will find short tutorials, primarily in R and Python, on a number of data related topics including access, cleaning, analysis, and visualization.\nTopics are organized into themes, with individual topics called dispatches.\n\nWhat’s a Dispatch?\nDispatches are short tutorials on a number of data subjects. Use the navigation on the left to find tutorials of interest, or use the search function in the top of the sidebar.\n\n\n\nTopic\nDescription\n\n\n\n\n📊 Data Visualization\nTopics in Data Visualization, primarily in the R library ggplot2\n\n\n👩🏻‍💻 API Guides\nAPI examples for common open data sources and JHU databases\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteNew dispatches are added frequently, so check back regularly for new tutorials!\n\n\n\n\n\n\n\n\nAbout Data Services",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "dispatches/data-access/us-census-acs.html",
    "href": "dispatches/data-access/us-census-acs.html",
    "title": "US Census API in R with tidycensus",
    "section": "",
    "text": "R conveniently has a number of packages designed to simplify access to the US Census API.\nFor this dispatch, we will review tidycensus, an R package that allows you to interface with a subset of the US Census Bureau’s APIs and return tidyverse-ready data frames."
  },
  {
    "objectID": "dispatches/data-visualization/visualizing-clusters.html",
    "href": "dispatches/data-visualization/visualizing-clusters.html",
    "title": "Visualizing Clusters",
    "section": "",
    "text": "library(palmerpenguins)\n\n\nAttaching package: 'palmerpenguins'\n\n\nThe following objects are masked from 'package:datasets':\n\n    penguins, penguins_raw\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\nlibrary(magrittr)",
    "crumbs": [
      "Data Visualization",
      "Visualizing Clusters"
    ]
  },
  {
    "objectID": "dispatches/data-visualization/visualizing-clusters.html#visualizing-clusters-with-a-convex-hull",
    "href": "dispatches/data-visualization/visualizing-clusters.html#visualizing-clusters-with-a-convex-hull",
    "title": "Visualizing Clusters",
    "section": "Visualizing clusters with a convex hull",
    "text": "Visualizing clusters with a convex hull\n\npenguins %&lt;&gt;% filter_at(vars(bill_length_mm, body_mass_g), all_vars(!is.na(.)))\n\npenguin_hull &lt;- penguins %&gt;%\n  group_by(species) %&gt;%\n  slice(chull(bill_length_mm, body_mass_g))\n\nggplot(data = penguins,\n       aes(x = bill_length_mm,\n           y = body_mass_g,\n           color = species,\n           labels = species)) +\n  geom_point(size = 2) +\n  geom_polygon(\n    data = penguin_hull,\n    aes(x = bill_length_mm,\n        y = body_mass_g,\n        fill = species),\n    alpha = 0.5,\n    show.legend = FALSE\n  ) +\n  xlab(\"Bill Length (mm)\") +\n  ylab(\"Body Mass (g)\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Data Visualization",
      "Visualizing Clusters"
    ]
  },
  {
    "objectID": "dispatches/data-visualization/custom-ggplot2-theme.html",
    "href": "dispatches/data-visualization/custom-ggplot2-theme.html",
    "title": "Building a custom ggplot2 theme",
    "section": "",
    "text": "In this dispatch we will learn how to build your own custom theme in ggplot2. This is useful if you want your figures to use a consistent style.\nMaybe you frequently submit to a specific journal which has an explicit style guide, and you want to ensure your figures are consistent with that style guide.\nIt can be a lot of work, and a lot of code to get the aesthetics of your ggplot2 figure just right. Instead of changing the font type, size, coloring, etc. every time you create a plot, just create a theme, that can then be applied to every new figure you create!\nLet’s create a plot using the default style in ggplot2, and explore some of the default themes to get a better understanding of what a ggplot2 theme looks like, and how it’s structured.",
    "crumbs": [
      "Data Visualization",
      "Building a custom `ggplot2` theme"
    ]
  },
  {
    "objectID": "dispatches/data-visualization/custom-ggplot2-theme.html#setup",
    "href": "dispatches/data-visualization/custom-ggplot2-theme.html#setup",
    "title": "Building a custom ggplot2 theme",
    "section": "Setup",
    "text": "Setup\nWe will be using the Palmer Penguins dataset for this dispatch. To install the Palmer Penguins package, run install.packages(\"palmerpenguins\").\nIf you have not already installed ggplot2, do so with install.packages(\"ggplot2\"), or install the entire tidyverse with install.packages(\"tidyverse\").\n\nLoad the Data\nNow load our two libraries:\n\nlibrary(palmerpenguins)\n\n\nAttaching package: 'palmerpenguins'\n\n\nThe following objects are masked from 'package:datasets':\n\n    penguins, penguins_raw\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\nExplore the Data\nWe are using the palmerpenguins package for our data during this dispatch. Data were collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER, a member of the Long Term Ecological Research Network. The data were conveniently collected as an R package that we use today.\n\nWe can get a sense of the contents of our data by looking at the first few rows of our tibble. Remember tibbles are data.frames, just with a few behavioral changes. The palmerpenguins data is in a tibble format by default.\n\ndata(package = 'palmerpenguins')\n\n# Remove rows that contain at least one missing value\npenguins &lt;- penguins %&gt;%\n            drop_na()\n\nprint(penguins)\n\n# A tibble: 333 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           36.7          19.3               193        3450\n 5 Adelie  Torgersen           39.3          20.6               190        3650\n 6 Adelie  Torgersen           38.9          17.8               181        3625\n 7 Adelie  Torgersen           39.2          19.6               195        4675\n 8 Adelie  Torgersen           41.1          17.6               182        3200\n 9 Adelie  Torgersen           38.6          21.2               191        3800\n10 Adelie  Torgersen           34.6          21.1               198        4400\n# ℹ 323 more rows\n# ℹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;",
    "crumbs": [
      "Data Visualization",
      "Building a custom `ggplot2` theme"
    ]
  },
  {
    "objectID": "dispatches/data-visualization/custom-ggplot2-theme.html#themes",
    "href": "dispatches/data-visualization/custom-ggplot2-theme.html#themes",
    "title": "Building a custom ggplot2 theme",
    "section": "Themes",
    "text": "Themes\nLet’s look at a few themes before we build our own. We can use these themes as a starting place.\n\nDefault theme\nThe default theme is theme_gray(). This is the theme that is used when you call ggplot without specifying a theme.\nWhen we compare penguin flipper length to penguin body mass by species the plot created uses theme_gray():\n\nggplot(data = penguins, aes(x = body_mass_g,\n                            y = flipper_length_mm,\n                            color = species)) +\n  geom_point() +\n  xlab(\"Body Mass (g)\") +\n  ylab(\"Flipper Length (mm)\")\n\n\n\n\n\n\n\n\nWe can explicitly add the theme and see that nothing changes:\n\nggplot(data = penguins, aes(x = body_mass_g,\n                            y = flipper_length_mm,\n                            color = species)) +\n  geom_point() +\n  xlab(\"Body Mass (g)\") +\n  ylab(\"Flipper Length (mm)\") +\n  theme_grey()\n\n\n\n\n\n\n\n\n\n\nChanging theme\nBut if we change the theme, we see our scatter plot change accordingly. Let’s use theme_minimal():\n\nggplot(data = penguins, aes(x = body_mass_g,\n                            y = flipper_length_mm,\n                            color = species)) +\n  geom_point() +\n  xlab(\"Body Mass (g)\") +\n  ylab(\"Flipper Length (mm)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\nAvailable themes\nThere are a number of themes available in ggplot2:\n\n\n\n\n\n\n\nTheme\nDescription\n\n\n\n\ntheme_gray()\nThe signature ggplot2 theme with a grey background and white gridlines, designed to put the data forward yet make comparisons easy.\n\n\ntheme_bw()\nThe classic dark-on-light ggplot2 theme. May work better for presentations displayed with a projector.\n\n\ntheme_linedraw()\nA theme with only black lines of various widths on white backgrounds, reminiscent of a line drawing. Serves a purpose similar to theme_bw(). Note that this theme has some very thin lines (&lt;&lt; 1 pt) which some journals may refuse.\n\n\ntheme_light()\nA theme similar to theme_linedraw() but with light grey lines and axes, to direct more attention towards the data.\n\n\ntheme_dark()\nThe dark cousin of theme_light(), with similar line sizes but a dark background. Useful to make thin coloured lines pop out.\n\n\ntheme_minimal()\nA minimalistic theme with no background annotations.\n\n\ntheme_classic()\nA classic-looking theme, with x and y axis lines and no gridlines.\n\n\ntheme_void()\nA completely empty theme.\n\n\ntheme_test()\nA theme for visual unit tests. It should ideally never change except for new features.",
    "crumbs": [
      "Data Visualization",
      "Building a custom `ggplot2` theme"
    ]
  },
  {
    "objectID": "dispatches/data-visualization/custom-ggplot2-theme.html#customizing-a-theme",
    "href": "dispatches/data-visualization/custom-ggplot2-theme.html#customizing-a-theme",
    "title": "Building a custom ggplot2 theme",
    "section": "Customizing a theme",
    "text": "Customizing a theme\nEach of the previous theme changes different aesthetics of the theme. We can specify our own using a custom theme. For a list of parameters that we can change, check out the theme help with ?theme or review the documentation on ggplot2 theming:\n\n\n\n\n\nUnderstanding theme contents\nLet’s look at the theme_minimal() function, and see what arguments are defined for the different theme parameters:\n\ntheme_minimal\n\nfunction (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n    base_rect_size = base_size/22) \n{\n    theme_bw(base_size = base_size, base_family = base_family, \n        base_line_size = base_line_size, base_rect_size = base_rect_size) %+replace% \n        theme(axis.ticks = element_blank(), legend.background = element_blank(), \n            legend.key = element_blank(), panel.background = element_blank(), \n            panel.border = element_blank(), strip.background = element_blank(), \n            plot.background = element_blank(), complete = TRUE)\n}\n&lt;bytecode: 0x13ba2ada0&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\nInteresting! We can see that theme_minimal() just builds on and modifies theme_bw().\nWhat would we find if we look at theme_bw()?\n\ntheme_bw\n\nfunction (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n    base_rect_size = base_size/22) \n{\n    theme_grey(base_size = base_size, base_family = base_family, \n        base_line_size = base_line_size, base_rect_size = base_rect_size) %+replace% \n        theme(panel.background = element_rect(fill = \"white\", \n            colour = NA), panel.border = element_rect(fill = NA, \n            colour = \"grey20\"), panel.grid = element_line(colour = \"grey92\"), \n            panel.grid.minor = element_line(linewidth = rel(0.5)), \n            strip.background = element_rect(fill = \"grey85\", \n                colour = \"grey20\"), complete = TRUE)\n}\n&lt;bytecode: 0x13ba2f740&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\ntheme_bw() builds on and modifies theme_grey(). Clearly a pattern is emerging where each ggplot2 theme modifies and builds on another.\nAnd what if we keep going down the rabbit hole and look at theme_grey()?\n\ntheme_grey\n\nfunction (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n    base_rect_size = base_size/22) \n{\n    half_line &lt;- base_size/2\n    t &lt;- theme(line = element_line(colour = \"black\", linewidth = base_line_size, \n        linetype = 1, lineend = \"butt\"), rect = element_rect(fill = \"white\", \n        colour = \"black\", linewidth = base_rect_size, linetype = 1), \n        text = element_text(family = base_family, face = \"plain\", \n            colour = \"black\", size = base_size, lineheight = 0.9, \n            hjust = 0.5, vjust = 0.5, angle = 0, margin = margin(), \n            debug = FALSE), axis.line = element_blank(), axis.line.x = NULL, \n        axis.line.y = NULL, axis.text = element_text(size = rel(0.8), \n            colour = \"grey30\"), axis.text.x = element_text(margin = margin(t = 0.8 * \n            half_line/2), vjust = 1), axis.text.x.top = element_text(margin = margin(b = 0.8 * \n            half_line/2), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.8 * \n            half_line/2), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.8 * \n            half_line/2), hjust = 0), axis.text.r = element_text(margin = margin(l = 0.8 * \n            half_line/2, r = 0.8 * half_line/2), hjust = 0.5), \n        axis.ticks = element_line(colour = \"grey20\"), axis.ticks.length = unit(half_line/2, \n            \"pt\"), axis.ticks.length.x = NULL, axis.ticks.length.x.top = NULL, \n        axis.ticks.length.x.bottom = NULL, axis.ticks.length.y = NULL, \n        axis.ticks.length.y.left = NULL, axis.ticks.length.y.right = NULL, \n        axis.minor.ticks.length = rel(0.75), axis.title.x = element_text(margin = margin(t = half_line/2), \n            vjust = 1), axis.title.x.top = element_text(margin = margin(b = half_line/2), \n            vjust = 0), axis.title.y = element_text(angle = 90, \n            margin = margin(r = half_line/2), vjust = 1), axis.title.y.right = element_text(angle = -90, \n            margin = margin(l = half_line/2), vjust = 1), legend.background = element_rect(colour = NA), \n        legend.spacing = unit(2 * half_line, \"pt\"), legend.spacing.x = NULL, \n        legend.spacing.y = NULL, legend.margin = margin(half_line, \n            half_line, half_line, half_line), legend.key = NULL, \n        legend.key.size = unit(1.2, \"lines\"), legend.key.height = NULL, \n        legend.key.width = NULL, legend.key.spacing = unit(half_line, \n            \"pt\"), legend.text = element_text(size = rel(0.8)), \n        legend.title = element_text(hjust = 0), legend.ticks.length = rel(0.2), \n        legend.position = \"right\", legend.direction = NULL, legend.justification = \"center\", \n        legend.box = NULL, legend.box.margin = margin(0, 0, 0, \n            0, \"cm\"), legend.box.background = element_blank(), \n        legend.box.spacing = unit(2 * half_line, \"pt\"), panel.background = element_rect(fill = \"grey92\", \n            colour = NA), panel.border = element_blank(), panel.grid = element_line(colour = \"white\"), \n        panel.grid.minor = element_line(linewidth = rel(0.5)), \n        panel.spacing = unit(half_line, \"pt\"), panel.spacing.x = NULL, \n        panel.spacing.y = NULL, panel.ontop = FALSE, strip.background = element_rect(fill = \"grey85\", \n            colour = NA), strip.clip = \"inherit\", strip.text = element_text(colour = \"grey10\", \n            size = rel(0.8), margin = margin(0.8 * half_line, \n                0.8 * half_line, 0.8 * half_line, 0.8 * half_line)), \n        strip.text.x = NULL, strip.text.y = element_text(angle = -90), \n        strip.text.y.left = element_text(angle = 90), strip.placement = \"inside\", \n        strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(half_line/2, \n            \"pt\"), strip.switch.pad.wrap = unit(half_line/2, \n            \"pt\"), plot.background = element_rect(colour = \"white\"), \n        plot.title = element_text(size = rel(1.2), hjust = 0, \n            vjust = 1, margin = margin(b = half_line)), plot.title.position = \"panel\", \n        plot.subtitle = element_text(hjust = 0, vjust = 1, margin = margin(b = half_line)), \n        plot.caption = element_text(size = rel(0.8), hjust = 1, \n            vjust = 1, margin = margin(t = half_line)), plot.caption.position = \"panel\", \n        plot.tag = element_text(size = rel(1.2), hjust = 0.5, \n            vjust = 0.5), plot.tag.position = \"topleft\", plot.margin = margin(half_line, \n            half_line, half_line, half_line), complete = TRUE)\n    ggplot_global$theme_all_null %+replace% t\n}\n&lt;bytecode: 0x1291aa138&gt;\n&lt;environment: namespace:ggplot2&gt;\n\n\nWe have reached the bottom of the rabbit hole with theme_grey(). This theme explicitly specifies all of the theme arguments (of which there are many).\n\nThis explains why all of the other themes build on each other, it is much more concise to only use a theme where all the arguments are already defined, and only change those theme arguments that you want to look different than the theme you are building on.\n\n\nCopying and modifying a theme\nLet’s begin to build a custom theme, and explore different arguments as we do. First lets create a new theme, theme_custom(), that is simply a wrapper to theme minimal:\n\ntheme_custom &lt;- function()\n{\n  theme_minimal()\n}\n\nWe can call our theme:\n\nggplot(data = penguins, aes(x = body_mass_g,\n                            y = flipper_length_mm,\n                            color = species)) +\n  geom_point() +\n  xlab(\"Body Mass (g)\") +\n  ylab(\"Flipper Length (mm)\") +\n  theme_custom()\n\n\n\n\n\n\n\n\nAnd we see that we get the same output as when we use theme_minimal().",
    "crumbs": [
      "Data Visualization",
      "Building a custom `ggplot2` theme"
    ]
  },
  {
    "objectID": "dispatches/data-visualization/distributions-ggplot2.html",
    "href": "dispatches/data-visualization/distributions-ggplot2.html",
    "title": "Tutorials",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dispatches/data-visualization/distributions-ggplot2.html#this-is-a-quarto-website.",
    "href": "dispatches/data-visualization/distributions-ggplot2.html#this-is-a-quarto-website.",
    "title": "Tutorials",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dispatches/data-visualization/order-by-multiple-variables.html",
    "href": "dispatches/data-visualization/order-by-multiple-variables.html",
    "title": "Ordering a ggplot2 barplot by multiple variables",
    "section": "",
    "text": "Sometimes you would like to order your barplots by multiple variables. For example, you would like to sort by a categorical variable, and then within each categorical variable sort by a continuous variable. Let’s take a look at an example:\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(forcats)\n\n\nstarwars %&gt;% \n  group_by(homeworld) %&gt;% \n  count() %&gt;% \n  arrange(-n)\n\n# A tibble: 49 × 2\n# Groups:   homeworld [49]\n   homeworld     n\n   &lt;chr&gt;     &lt;int&gt;\n 1 Naboo        11\n 2 Tatooine     10\n 3 &lt;NA&gt;         10\n 4 Alderaan      3\n 5 Coruscant     3\n 6 Kamino        3\n 7 Corellia      2\n 8 Kashyyyk      2\n 9 Mirial        2\n10 Ryloth        2\n# ℹ 39 more rows\n\nstarwars %&gt;% \n  filter(is.na(homeworld))\n\n# A tibble: 10 × 14\n   name     height  mass hair_color skin_color eye_color birth_year sex   gender\n   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n 1 Yoda         66    17 white      green      brown            896 male  mascu…\n 2 IG-88       200   140 none       metal      red               15 none  mascu…\n 3 Arvel C…     NA    NA brown      fair       brown             NA male  mascu…\n 4 Qui-Gon…    193    89 brown      fair       blue              92 male  mascu…\n 5 R4-P17       96    NA none       silver, r… red, blue         NA none  femin…\n 6 Finn         NA    NA black      dark       dark              NA male  mascu…\n 7 Rey          NA    NA brown      light      hazel             NA fema… femin…\n 8 Poe Dam…     NA    NA brown      light      brown             NA male  mascu…\n 9 BB8          NA    NA none       none       black             NA none  mascu…\n10 Captain…     NA    NA none       none       unknown           NA fema… femin…\n# ℹ 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,\n#   vehicles &lt;list&gt;, starships &lt;list&gt;\n\nstarwars &lt;- starwars %&gt;% \n  mutate(homeworld = replace_na(homeworld, \"Unknown\")) %&gt;%\n  filter(homeworld %in% c(\"Naboo\", \"Tatooine\", \"Unknown\")) %&gt;%\n  drop_na(height) %&gt;% \n  mutate(name = factor(name)) %&gt;% \n  mutate(name = fct_reorder(name, height)) %&gt;% \n  mutate(name = fct_reorder(name, homeworld))\n\nggplot(starwars, mapping = aes(x = height, y = name, fill = homeworld)) +\n  geom_bar(stat = \"identity\") +\n  xlab(\"Character Height (in inches)\") +\n  ylab(\"Character\") +\n  scale_fill_manual(values = c(\"darkorange\",\"purple\",\"cyan4\"),\n                    guide = guide_legend(reverse = TRUE),\n                    name = \"Homeworld\") +\n  theme_minimal()",
    "crumbs": [
      "Data Visualization",
      "Ordering a `ggplot2` barplot by multiple variables"
    ]
  },
  {
    "objectID": "dispatches/data-access/managing-secrets.html",
    "href": "dispatches/data-access/managing-secrets.html",
    "title": "Managing Secrets",
    "section": "",
    "text": "To use an application programming interface, or API, you will need an API key.",
    "crumbs": [
      "Access and APIs",
      "Managing Secrets"
    ]
  },
  {
    "objectID": "dispatches/data-access/managing-secrets.html#what-is-an-api-key",
    "href": "dispatches/data-access/managing-secrets.html#what-is-an-api-key",
    "title": "Managing Secrets",
    "section": "What is an API Key?",
    "text": "What is an API Key?\nAn API key is a unique code used to identify and authenticate a user or application when interacting with an API.\nAPI keys are generally a string of alphanumeric characters, and look something like this:\nzaCELgL0imfnc8mVLWwsAawjYr4RxAf50DDqtlx\nAPI keys are a security measure to make sure you, or your application, are who you say you are.\nThink of it like an ID card. You wouldn’t want to leave your ID card laying around, and you don’t want to leave your API key laying around either. Anyone could just pick it up and pretend they are you!\nSince API keys are plain text, if API keys are stored in your code, when you share your code, such as on GitHub, they will be readable by everyone that has access to that GitHub repository.\nConsider this R code below that retrieves data from the US decennial census:\n\nlibrary(tidycensus)\nlibrary(tidyverse)\n\ncensus_api_key(\"zaCELgL0imfnc8mVLWwsAawjYr4RxAf50DDqtl\")\n\n# Retrieve median age by sex (P13_001N) by state\nage_2020 &lt;- get_decennial(geography = \"state\", \n                       variables = \"P13_001N\", \n                       year = 2020,\n                       sumfile = \"dhc\")\n\nThe API key is stored in plain-text as a variable. If this code were shared, anyone would be able to use the API key.",
    "crumbs": [
      "Access and APIs",
      "Managing Secrets"
    ]
  },
  {
    "objectID": "dispatches/data-access/managing-secrets.html#how-do-we-protect-api-keys",
    "href": "dispatches/data-access/managing-secrets.html#how-do-we-protect-api-keys",
    "title": "Managing Secrets",
    "section": "How do we protect API keys?",
    "text": "How do we protect API keys?\n\nWe need some way of using an API key in our code without making it shareable.\nThere are a number of ways we can accomplish this, but this dispatch will focus on one way that is both platform agnostic (works on Mac, Windows, and Linux) and works in most programming languages; environment variables.\n\nEnvironment Variables\nA variable allows us to store information, and an environment is the system we execute our code on. Environment variables allow us to store information specific to a system in variables. Environment variables are not stored within our codebase, but are instead stored in a system specific configuration file.\nWe can use the environment variables configuration file to store our API key, and reference the configuration file in our code in order to load the API key.\n\nEnvironment Variables in R\nIn R, environment variables can be stored in a text file with name-value pairs. Create a file in your home directory by running:\n\nfile.edit(\"~/.Renviron\")\n\nUsing the API key listed earlier, we would declare an environment variable in our .Renviron file:\n\nAPI_KEY = \"zaCELgL0imfnc8mVLWwsAawjYr4RxAf50DDqtlx\"\n\nNow we can update our code to retrieve our API environment variable:\n\nlibrary(tidycensus)\nlibrary(tidyverse)\n\n# Retrieve API key from .Renviron file\napi_key &lt;- Sys.getenv(\"API_KEY\")\ncensus_api_key(api_key)\n\n# Retrieve median age by sex (P13_001N) by state\nage_2020 &lt;- get_decennial(geography = \"state\", \n                       variables = \"P13_001N\", \n                       year = 2020,\n                       sumfile = \"dhc\")\n\nOur API key is now secret, and will not be shared with our codebase!",
    "crumbs": [
      "Access and APIs",
      "Managing Secrets"
    ]
  },
  {
    "objectID": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html",
    "href": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html",
    "title": "Introduction to APIs in R",
    "section": "",
    "text": "This document has the completed code for the Johns Hopkins Data Services October 22nd session Introduction to APIs in R.\n\n\n\n## Library for working with RESTful APIs \nlibrary(httr2)\n\n## Libraries for data processing\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(tibble)\n\n## Library for viewing dataframe as HTML table\nlibrary(DT)",
    "crumbs": [
      "Access and APIs",
      "Introduction to APIs in R"
    ]
  },
  {
    "objectID": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#introduction",
    "href": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#introduction",
    "title": "Introduction to APIs in R",
    "section": "",
    "text": "This document has the completed code for the Johns Hopkins Data Services October 22nd session Introduction to APIs in R.\n\n\n\n## Library for working with RESTful APIs \nlibrary(httr2)\n\n## Libraries for data processing\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(tibble)\n\n## Library for viewing dataframe as HTML table\nlibrary(DT)",
    "crumbs": [
      "Access and APIs",
      "Introduction to APIs in R"
    ]
  },
  {
    "objectID": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#introduction-to-requests",
    "href": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#introduction-to-requests",
    "title": "Introduction to APIs in R",
    "section": "Introduction to Requests",
    "text": "Introduction to Requests\nUse the PokeAPI to extract basic information about Pokémon using a series of API requests.\n\nSet the url for the API and set our endpoint (pokemon)\n\nbase_url &lt;- 'https://pokeapi.co/api/v2/'\nendpoint &lt;- 'pokemon'\n\n\n\nUse req_url_path_append() to construct the endpoint path\n\nrequest &lt;- request(base_url) |&gt; \n    req_url_path_append(endpoint)\n\nWe can see the get request formed by our request function:\n\nrequest\n\n&lt;httr2_request&gt;\nGET https://pokeapi.co/api/v2/pokemon\nBody: empty\n\n\n\n\nGenerate a response by performing our request using req_perform(request)\n\nresponse &lt;- req_perform(request)\n\nLet’s take a look at the contents of our raw response body:\n\nresponse$body\n\n   [1] 7b 22 63 6f 75 6e 74 22 3a 31 33 32 38 2c 22 6e 65 78 74 22 3a 22 68 74\n  [25] 74 70 73 3a 2f 2f 70 6f 6b 65 61 70 69 2e 63 6f 2f 61 70 69 2f 76 32 2f\n  [49] 70 6f 6b 65 6d 6f 6e 3f 6f 66 66 73 65 74 3d 32 30 26 6c 69 6d 69 74 3d\n  [73] 32 30 22 2c 22 70 72 65 76 69 6f 75 73 22 3a 6e 75 6c 6c 2c 22 72 65 73\n  [97] 75 6c 74 73 22 3a 5b 7b 22 6e 61 6d 65 22 3a 22 62 75 6c 62 61 73 61 75\n [121] 72 22 2c 22 75 72 6c 22 3a 22 68 74 74 70 73 3a 2f 2f 70 6f 6b 65 61 70\n [145] 69 2e 63 6f 2f 61 70 69 2f 76 32 2f 70 6f 6b 65 6d 6f 6e 2f 31 2f 22 7d\n [169] 2c 7b 22 6e 61 6d 65 22 3a 22 69 76 79 73 61 75 72 22 2c 22 75 72 6c 22\n [193] 3a 22 68 74 74 70 73 3a 2f 2f 70 6f 6b 65 61 70 69 2e 63 6f 2f 61 70 69\n [217] 2f 76 32 2f 70 6f 6b 65 6d 6f 6e 2f 32 2f 22 7d 2c 7b 22 6e 61 6d 65 22\n....\n\n\nWe see that our output is raw byte codes - as series of two character hexadecimal values. This is because we need to tell the httr2 library to intepret the body as a JSON. We can use glimpse() to make our JSON output more readable.\n\nresponse |&gt; \n    resp_body_json() |&gt; \n    glimpse()\n\nList of 4\n $ count   : int 1328\n $ next    : chr \"https://pokeapi.co/api/v2/pokemon?offset=20&limit=20\"\n $ previous: NULL\n $ results :List of 20\n  ..$ :List of 2\n  .. ..$ name: chr \"bulbasaur\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/pokemon/1/\"\n  ..$ :List of 2\n  .. ..$ name: chr \"ivysaur\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/pokemon/2/\"\n  ..$ :List of 2\n  .. ..$ name: chr \"venusaur\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/pokemon/3/\"\n  ..$ :List of 2\n....\n\n\n\n\nRequest a specific pokemon endpoint\n\nDefine an endpoint for bulbasaur\nPerform the request\nDisplay the response\n\n\nresponse &lt;- request(base_url) |&gt;\n    req_url_path_append(endpoint, 'bulbasaur') |&gt; \n    req_perform() |&gt; \n    resp_body_json()\n\nresponse |&gt; glimpse()\n\nList of 20\n $ abilities               :List of 2\n  ..$ :List of 3\n  .. ..$ ability  :List of 2\n  .. ..$ is_hidden: logi FALSE\n  .. ..$ slot     : int 1\n  ..$ :List of 3\n  .. ..$ ability  :List of 2\n  .. ..$ is_hidden: logi TRUE\n  .. ..$ slot     : int 3\n $ base_experience         : int 64\n $ cries                   :List of 2\n  ..$ latest: chr \"https://raw.githubusercontent.com/PokeAPI/cries/main/cries/pokemon/latest/1.ogg\"\n  ..$ legacy: chr \"https://raw.githubusercontent.com/PokeAPI/cries/main/cries/pokemon/legacy/1.ogg\"\n $ forms                   :List of 1\n....",
    "crumbs": [
      "Access and APIs",
      "Introduction to APIs in R"
    ]
  },
  {
    "objectID": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#manipulating-json-data",
    "href": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#manipulating-json-data",
    "title": "Introduction to APIs in R",
    "section": "Manipulating JSON data",
    "text": "Manipulating JSON data\n\nExtract data from a JSON into a tibble (dataframe)\nJSON data is variably nested and can be difficult to work with. For example, what if we want to retrieve the stats for bulbasaur and format it like:\n\n\n\nStat Name\nStat\n\n\n\n\nHP\n30\n\n\nAttack\n25\n\n\nDefense\n35\n\n\n\nWe can see that stats are nested in a hierarchy of lists, and are difficult to retreive by name:\n\nstr(response$stats)\n\nList of 6\n $ :List of 3\n  ..$ base_stat: int 45\n  ..$ effort   : int 0\n  ..$ stat     :List of 2\n  .. ..$ name: chr \"hp\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/stat/1/\"\n $ :List of 3\n  ..$ base_stat: int 49\n  ..$ effort   : int 0\n  ..$ stat     :List of 2\n  .. ..$ name: chr \"attack\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/stat/2/\"\n $ :List of 3\n  ..$ base_stat: int 49\n  ..$ effort   : int 0\n  ..$ stat     :List of 2\n  .. ..$ name: chr \"defense\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/stat/3/\"\n $ :List of 3\n  ..$ base_stat: int 65\n  ..$ effort   : int 1\n  ..$ stat     :List of 2\n  .. ..$ name: chr \"special-attack\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/stat/4/\"\n $ :List of 3\n  ..$ base_stat: int 65\n  ..$ effort   : int 0\n  ..$ stat     :List of 2\n  .. ..$ name: chr \"special-defense\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/stat/5/\"\n $ :List of 3\n  ..$ base_stat: int 45\n  ..$ effort   : int 0\n  ..$ stat     :List of 2\n  .. ..$ name: chr \"speed\"\n  .. ..$ url : chr \"https://pokeapi.co/api/v2/stat/6/\"\n\n\nOne strategy is to iterate over all six outer lists, each of which corresponds to a single statistics, and then extract the relevant information from the inner lists.\nWe can do this using the map_df() function from the purrr library. The map_df() iterates, or “maps”, over each list, allows us to perform a function, and returns the result as a dataframe.\nThe function takes the form map_df(my_list, ~ function(.x)) where the ~ represents an anonymous function that allows us to reference each list as .x.\nWe can extract all of the stats into a dataframe using:\n\nstats &lt;- map_df(\n  response$stats,\n  ~ tibble(stat_name = .x$stat$name, stat = .x$base_stat)\n)\n\nwhich gives us:\n\nstats\n\n# A tibble: 6 × 2\n  stat_name        stat\n  &lt;chr&gt;           &lt;int&gt;\n1 hp                 45\n2 attack             49\n3 defense            49\n4 special-attack     65\n5 special-defense    65\n6 speed              45\n\n\nThe rest of the data is easier to extract from response, so by using both our stats tibble we created, as well as the original response, we can create a tibble of bulbasaur stats:\n\nbulbasaur_stats &lt;- tibble(\n  sprite = response$sprites$front_default,\n  species = response$species$name,\n  height = response$height,\n  weight = response$weight,\n  hp = stats$stat[stats$stat_name == \"hp\"],\n  defense = stats$stat[stats$stat_name == \"defense\"],\n  attack = stats$stat[stats$stat_name == \"attack\"])\n\nbulbasaur_stats\n\n# A tibble: 1 × 7\n  sprite                              species height weight    hp defense attack\n  &lt;chr&gt;                               &lt;chr&gt;    &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt;  &lt;int&gt;\n1 https://raw.githubusercontent.com/… bulbas…      7     69    45      49     49",
    "crumbs": [
      "Access and APIs",
      "Introduction to APIs in R"
    ]
  },
  {
    "objectID": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#pagination",
    "href": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#pagination",
    "title": "Introduction to APIs in R",
    "section": "Pagination",
    "text": "Pagination\n\nUsing pagination to request data for 100 pokemon\nWhat if we want stats for more than one pokemon? We need to find some way of making multiple requests for each pokemon.\nLet’s create a request for 20 pokemon. We can use req_url_query() to pass specific parameters to our get request; in this case we will pass limit=20 to request 20 records:\n\nrequest &lt;- request(base_url) |&gt; \n    req_url_path_append('pokemon') |&gt; \n    req_url_query(limit = 20)\n\nIf we perform a single request, and examine it, we see an interesting attribute - next:\n\nresponse &lt;- req_perform(request) |&gt; resp_body_json()\nresponse$`next`\n\n[1] \"https://pokeapi.co/api/v2/pokemon?offset=20&limit=20\"\n\n\nNext is delivered as part of our JSON. It tells us, if we wanted the next batch of records, exactly what API call we would need to make. We can think of these as a chain of API calls that allow us to iterate through all records available to us:\n...okemon?offset=20&limit=20\" -&gt; ...okemon?offset=40&limit=20\" -&gt; ...okemon?offset=60&limit=20\" …\nand so on until we end up reaching the end, which we know is the end because next == NULL - there are no more records past the last API call.\nSo how do we request multiple pokemon stats? There are different strategies, which you will find is often the case when working with APIs. We will:\n\nUse the req_perform_iterative() function to iterate over multiple batches of records until we have all 1,328 pokemon. Learn more about req_perform_iterative.\nCreate our own function, req_paged_next() which will help us update each step of req_perform_iterative() to use the next record available.\nIterate over all of the responses, and extract the name and url endpoint for each pokemon.\nCreate a function that generalizes the process of extracting pokemon statistics from a JSON, as we did with bulbasaur.\nUsing the list of pokemon URLs, make 1,328 API requests, one for each pokemon, and extract the statistics for each pokemon.\n\nWe can extract all the pokemon using:\n\nresponses &lt;- req_perform_iterative(\n    request,\n    next_req = SOME_HELPER_FUNCTION,\n    on_error = \"return\" # If request fails, stop and return what you have\n)\n\nnext_req take’s a function, with the arguments (resp, req).\nNormally we could use one of the httr2 provided iteration helper functions to help us iterate over.\n\n\n\n\n\n\nThese functions are intended for use with the next_req argument to req_perform_iterative().\nEach implements iteration for a common pagination pattern:\n\n\n\n\niterate_with_offset() — increments a query parameter, e.g. ?page=1, ?page=2, or ?offset=1, offset=21.\niterate_with_cursor() — updates a query parameter with the value of a cursor found somewhere in the response.\niterate_with_link_url() — follows the URL found in the Link header. See resp_link_url() for more details.\n\nThe problem is, our next url is not included in the Link header, as is common, but is instead part of our JSON. This means we will need to write and provide a custom function to provide it to req_perform_iterative.\n\n\nLet’s build a next page handler\nOur next page handler takes two arguments, resp and req. These stand for response and request, respectively. We must use these abbreviations, because that is what the req_perform_iterative next_req argument expects.\nOur next page handler does the following:\n\nExtracts the JSON body: resp_body_json(resp)\nGrabs the next url response_body$next``\nChecks if the next URL is NULL, and returns NULL if so. if (is.null(next_url)){return(NULL)}\nOtherwise updates the request with the new URL: req |&gt; req_url(next_url)\n\n\nnext_page_handler &lt;- function(resp, req) {\n  response_body &lt;- resp_body_json(resp)\n  next_url &lt;- response_body$`next`\n  ## Error handling - if we get to a next that returns NULL\n  ## then we stop. Otherwise keep navigating through our \n  ## chain of next URLs.\n  if (is.null(next_url)) {\n    return(NULL)\n  } else {\n    req |&gt; req_url(next_url)\n  }\n}\n\nWe can avoid hitting any API limits by using req_throttle() in request() to ensure we never exceed a specified rate.\nThrottling is implemented using a “token bucket”, which fills up to a maximum of capacity tokens over fill_time_s (fill time in seconds). Each time you make a request, it takes a token out of the bucket, and if the bucket is empty, the request will wait until the bucket refills. This ensures that you never make more than capacity requests in fill_time_s.\n\nrequest &lt;- request(\"https://pokeapi.co/api/v2/pokemon\") |&gt; \n  req_url_query(limit = 20) |&gt; \n  req_throttle(capacity = 10, fill_time_s = 60)\n\nNow let’s get all the first 100 pokemon (by setting max_reqs = 5). We can get all the pokemon by setting max_reqs = Inf, but be cautious of API limits.\n\nresponses &lt;- httr2::req_perform_iterative(\n  request,\n  next_req = next_page_handler,\n  max_reqs = 5,\n  on_error = \"return\"\n)\n\nNow we can use map_dfr() to iterate over each response and extract the results.\n\npokemon_names &lt;-\n  purrr::map_dfr(responses, function(response) {\n    body &lt;- httr2::resp_body_json(response)\n    purrr::map_dfr(body$results, tibble::as_tibble)\n  })\n\npokemon_names\n\n# A tibble: 100 × 2\n   name       url                                  \n   &lt;chr&gt;      &lt;chr&gt;                                \n 1 bulbasaur  https://pokeapi.co/api/v2/pokemon/1/ \n 2 ivysaur    https://pokeapi.co/api/v2/pokemon/2/ \n 3 venusaur   https://pokeapi.co/api/v2/pokemon/3/ \n 4 charmander https://pokeapi.co/api/v2/pokemon/4/ \n 5 charmeleon https://pokeapi.co/api/v2/pokemon/5/ \n 6 charizard  https://pokeapi.co/api/v2/pokemon/6/ \n 7 squirtle   https://pokeapi.co/api/v2/pokemon/7/ \n 8 wartortle  https://pokeapi.co/api/v2/pokemon/8/ \n 9 blastoise  https://pokeapi.co/api/v2/pokemon/9/ \n10 caterpie   https://pokeapi.co/api/v2/pokemon/10/\n# ℹ 90 more rows\n\n\n\n\nRetreive statistics for each pokemon through multiple API calls\nIn order to retrieve statsitics for each pokemon, we can iterate over each URL in pokemon_names and make a request for the specific pokemon endpoint represented by that url. To do this, we can build on our approach for extracting statistics from one pokemon, and build a function for multiple.\n\nget_pokemon_details &lt;- function(url) {\n\n  response &lt;- request(url) |&gt; req_perform() |&gt; resp_body_json()\n\n  ## We don't have ways to limit the number of requests over\n  ## a given time period, so we can use Sys.sleep to pause our\n  ## function before each request to ensure we don't exceed \n  ## API limits.\n  Sys.sleep(.5)\n  \n\n  stats &lt;- purrr:::map_df(\n    response$stats,\n    ~ tibble(stat_name = .x$stat$name, stat = .x$base_stat)\n  )\n\n  tibble(\n    sprite = response$sprites$front_default,\n    name = response$name,\n    height = response$height,\n    weight = response$weight,\n    hp = stats$stat[stats$stat_name == \"hp\"],\n    defense = stats$stat[stats$stat_name == \"defense\"],\n    attack = stats$stat[stats$stat_name == \"attack\"]\n  ) |&gt;\n    ## This mutate function wraps each sprite url in \n    ## &lt;img src=\"SPRITE_URL\"height=\"50\"&gt;&lt;/img&gt; so it can\n    ## be displayed in an HTML table using the DT library\n    mutate(sprite = paste0('&lt;img src=\"', sprite, '\" height=\"50\"&gt;&lt;/img&gt;'))\n}\n\nNow iterate over each pokemon URL and excecute the get_pokemon_details function to retrieve each pokemon’s statistics:\n\npokemon_stats &lt;- map_dfr(pokemon_names$url, get_pokemon_details)\n\nFinally, display our resultant table:\n\ndatatable(data = pokemon_stats, escape = FALSE)",
    "crumbs": [
      "Access and APIs",
      "Introduction to APIs in R"
    ]
  },
  {
    "objectID": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#api-key-privacy",
    "href": "dispatches/data-access/Introduction-to-APIs-in-R-Tutorial.html#api-key-privacy",
    "title": "Introduction to APIs in R",
    "section": "API key privacy",
    "text": "API key privacy\nWhat if you are working with an API that requires an API key?\nFor example, let’s use the NASA API to retreive weather data on mars:\nThis API is a little different. We have to specify our data type (JSON) and our API version (1.0) as parameters in our GET request:\n\nnasa_base_url &lt;- 'https://api.nasa.gov/'\n\nreq &lt;- request(nasa_base_url) |&gt;\n  req_url_path_append('insight_weather/') |&gt;\n  req_url_query(feedtype = \"json\", ver = \"1.0\") |&gt;\n  req_perform()\n\nError in `req_perform()`:\n! HTTP 403 Forbidden.\n\nreq\n\nError: object 'req' not found\n\n\nWe see that when we run it, we get a 403 HTTP error. We are not considered a valid user unless we provide an API key.\nYou can register for an API key with nothing but an email at https://api.nasa.gov/, or we can use the demo key that NASA provides for experimenting with their API (although it does have lower API limits than if you use your own key).\n\napi_key &lt;- 'DEMO_KEY'\n\nreq &lt;- request(nasa_base_url) |&gt;\n  req_url_path_append('insight_weather/') |&gt;\n  req_url_query(feedtype = \"json\", ver = \"1.0\", api_key = api_key) |&gt;\n  req_perform()\n  \nreq\n\n&lt;httr2_response&gt;\nGET https://api.nasa.gov/insight_weather/?feedtype=json&ver=1.0&api_key=DEMO_KEY\nStatus: 200 OK\nContent-Type: application/json\nBody: In memory (36505 bytes)\n\n\nNow that we passed the api_key as a parameter, we received a valid response (HTTP 200).\nWe don’t want to store that API key in plaintext though - anyone could steal it! Let’s store it as an environmental variable. To do that, you can add it to your .Renviron file in your home directory.\nYou can use an R package to edit that file directly in RStudio: usethis.\nusethis is a workflow package: it automates repetitive tasks that arise during project setup and development, both for R packages and non-package projects.\n\nlibrary(usethis)\nedit_r_environ()\n\n☐ Edit '/Users/plawson/.Renviron'.\n\n\n☐ Restart R for changes to take effect.\n\n\nAn editor window will open, and you can add the following (replacing \"DEMO_KEY\" with your own API key, if you registered for one)\nAPI_KEY = \"DEMO_KEY\"\nNow you can load your API key from your .Renviron file by first restarting R, and then:\n\napi_key &lt;- Sys.getenv(\"API_KEY\")\nnasa_base_url &lt;- 'https://api.nasa.gov/'\n\nreq &lt;- request(nasa_base_url) |&gt;\n  req_url_path_append('insight_weather/') |&gt;\n  req_url_query(feedtype = \"json\", ver = \"1.0\", api_key = api_key) |&gt;\n  req_perform()\n  \nreq\n\n&lt;httr2_response&gt;\nGET https://api.nasa.gov/insight_weather/?feedtype=json&ver=1.0&api_key=DEMO_KEY\nStatus: 200 OK\nContent-Type: application/json\nBody: In memory (36505 bytes)",
    "crumbs": [
      "Access and APIs",
      "Introduction to APIs in R"
    ]
  }
]